---
alwaysApply: true
description: 백엔드 테스트 전략 및 규칙 (E2E 테스트만, 실제 서버 실행)
---

# Backend Testing 규칙

## Overview

백엔드 테스트는 **E2E 테스트만** 사용합니다. 실제 서버를 띄워서 프로덕션 플로우와 동일하게 검증합니다.

## 핵심 원칙: 프로덕션 플로우 검증

### 테스트의 목적
- **목적**: 프로덕션에서 문제가 없음을 보장
- **원칙**: 테스트를 위한 테스트가 아니라, 프로덕션 안정성을 위한 테스트
- **기준**: 백엔드 테스트를 통과하면 바로 배포하여 서비스할 수 있어야 함

### 프로덕션 플로우와 동일하게 검증
1. **실제 서버 실행**
   - E2E 테스트는 반드시 실제 서버를 띄워서 실행
   - `conftest_e2e.py`에 `test_server` fixture 사용
   - `httpx.Client`로 실제 HTTP 요청
   - 백그라운드 작업이 완료될 때까지 상태를 폴링하여 검증

2. **백그라운드 작업 검증**
   - `FastAPI BackgroundTasks`는 실제 서버 환경에서만 제대로 실행됨
   - 실제 서버에서 백그라운드 작업이 실행되고 완료되는지 반드시 검증

3. **테스트를 위한 테스트 금지**
   - ❌ 서비스를 직접 호출하여 백그라운드 작업을 우회
   - ❌ 프로덕션 플로우와 다른 방식으로 테스트
   - ❌ 테스트 편의를 위해 실제 동작을 우회
   - ✅ 프로덕션과 동일한 플로우로 검증
   - ✅ 실제 사용자 시나리오와 동일하게 테스트

4. **DB 직접 조회 금지**
   - ⚠️ **중요**: 서버는 실제 파일 DB (`data/books.db`) 사용, 테스트는 메모리 DB (`:memory:`) 사용
   - ❌ 테스트에서 `db_session.query()`로 직접 조회 (서로 다른 DB이므로 데이터 없음)
   - ✅ API 응답만 검증 (프로덕션 플로우와 동일)

## Domain Knowledge

### E2E 테스트 원칙

- **실제 데이터만 사용** (Mock 사용 절대 금지)
- **실제 서버 실행**: 프로덕션 플로우와 동일하게 검증
- 실제 외부 API 연동 (Upstage, OpenAI)
- 실제 DB 데이터 검증
- 실제 PDF 파일 사용

## Standards & Conventions

### 테스트 프레임워크

```python
pytest              # 테스트 프레임워크
httpx               # 실제 HTTP 요청 클라이언트
pytest-cov          # 코드 커버리지 (선택)
```

### 테스트 파일 네이밍

- **테스트 파일**: `test_<feature>.py` 또는 `test_e2e_<feature>.py`
- **테스트 함수**: `test_<scenario>()` 또는 `test_e2e_<scenario>()`
- **Fixture 파일**: `conftest.py` 또는 `conftest_<type>.py` (예: `conftest_e2e.py`)
  - ⚠️ **중요**: `conftest*.py` 파일은 `test_` 접두사를 사용하지 않음
  - pytest가 자동으로 `conftest*.py` 파일을 발견하고 로드함
  - `test_conftest.py`로 이름을 변경하면 pytest가 인식하지 못함
  - 이것은 pytest의 표준 관행이며, 테스트 파일이 아닌 설정 파일임

### 테스트 마커

```python
@pytest.mark.e2e           # E2E 테스트 (실제 서버 실행)
@pytest.mark.slow          # 실행 시간이 긴 테스트
```

## Implementation Patterns

### 1. conftest_e2e.py 설정

```python
# backend/tests/conftest_e2e.py
import pytest
import subprocess
import httpx
import time
from pathlib import Path

TEST_SERVER_HOST = "127.0.0.1"
TEST_SERVER_PORT = 8001
TEST_SERVER_URL = f"http://{TEST_SERVER_HOST}:{TEST_SERVER_PORT}"

@pytest.fixture(scope="session")
def test_server():
    """E2E 테스트용 실제 서버 실행"""
    project_root = Path(__file__).parent.parent.parent
    
    # uvicorn 서버 시작
    server_process = subprocess.Popen(
        ["poetry", "run", "uvicorn", "backend.api.main:app", 
         "--host", TEST_SERVER_HOST, "--port", str(TEST_SERVER_PORT)],
        cwd=project_root
    )
    
    # 서버 시작 대기 (헬스체크)
    max_wait = 10
    for _ in range(max_wait):
        try:
            response = httpx.get(f"{TEST_SERVER_URL}/health", timeout=1.0)
            if response.status_code == 200:
                break
        except:
            time.sleep(0.5)
    else:
        raise RuntimeError("Test server failed to start")
    
    yield TEST_SERVER_URL
    
    # 서버 종료
    server_process.terminate()
    server_process.wait()

@pytest.fixture(scope="function")
def e2e_client(test_server):
    """E2E 테스트용 HTTP 클라이언트"""
    client = httpx.Client(base_url=test_server, timeout=30.0)
    yield client
    client.close()
```

### 2. E2E 테스트 패턴 (실제 서버 실행, 프로덕션 플로우 검증)

```python
# backend/tests/test_e2e_pdf_parsing.py
import pytest
import time
import httpx

@pytest.mark.e2e
def test_e2e_pdf_parsing_full_flow(e2e_client: httpx.Client, db_session, sample_pdf_path):
    """전체 플로우 E2E 테스트 (실제 서버 실행)"""
    # 1. PDF 업로드 (실제 HTTP 요청)
    with open(sample_pdf_path, "rb") as f:
        files = {"file": ("sample.pdf", f, "application/pdf")}
        response = e2e_client.post("/api/books/upload", files=files)
    
    assert response.status_code == 200
    book_id = response.json()["book_id"]
    
    # 2. 백그라운드 작업 검증 (프로덕션 플로우와 동일)
    # 실제 서버에서 백그라운드 작업이 실행되므로 상태 폴링
    max_wait_time = 300
    start_time = time.time()
    
    while True:
        elapsed = time.time() - start_time
        if elapsed > max_wait_time:
            pytest.fail(f"Background task timeout after {max_wait_time} seconds")
        
        response = e2e_client.get(f"/api/books/{book_id}")
        assert response.status_code == 200
        status = response.json()["status"]
        
        if status == "parsed":
            break
        elif status == "error_parsing":
            pytest.fail(f"Parsing failed: book_id={book_id}")
        
        time.sleep(2)
    
    # 3. 파싱 결과 검증
    response = e2e_client.get(f"/api/books/{book_id}")
    assert response.status_code == 200
    book_data = response.json()
    assert book_data["status"] == "parsed"
    assert book_data["page_count"] > 0
```

**⚠️ 주의사항:**
- E2E 테스트는 반드시 실제 서버를 띄워서 실행 (`conftest_e2e.py`의 `test_server` fixture 사용)
- `TestClient` 사용 금지 (백그라운드 작업이 제대로 실행되지 않음)
- `httpx.Client`로 실제 HTTP 요청
- 서비스를 직접 호출하여 백그라운드 작업을 우회하는 방식 금지
- 백그라운드 작업이 실제로 실행되고 완료되는지 반드시 검증

## 테스트 실행 방법

```powershell
# E2E 테스트 실행 (실제 서버 실행, 실제 API 호출)
poetry run pytest -m e2e backend/tests/

# 커버리지 포함 실행
poetry run pytest -m e2e --cov=backend --cov-report=html backend/tests/
```

## Checklist

### E2E 테스트 작성 시

- [ ] **실제 서버 실행** (`conftest_e2e.py`의 `test_server` fixture 사용)
- [ ] **실제 데이터만 사용** (Mock 사용 절대 금지)
- [ ] **프로덕션 플로우와 동일하게 검증** (실제 HTTP 요청 사용, `httpx.Client`)
- [ ] **백그라운드 작업 검증** (실제로 실행되고 완료되는지 확인)
- [ ] `TestClient` 사용 금지 (백그라운드 작업이 제대로 실행되지 않음)
- [ ] 실제 외부 API 연동 (Upstage, OpenAI)
- [ ] 실제 PDF 파일 사용
- [ ] 전체 플로우 검증
- [ ] 각 단계별 데이터 정합성 검증
- [ ] `@pytest.mark.e2e` 마커 추가
- [ ] **테스트를 위한 테스트 금지** (서비스 직접 호출로 우회 금지)
- [ ] **DB 직접 조회 금지** (서버와 테스트가 다른 DB 사용, API 응답만 검증)

### 테스트 커버리지 목표

- [ ] 전체 코드 커버리지: 80% 이상
- [ ] 핵심 모듈 커버리지: 90% 이상
  - UpstageAPIClient: 100%
  - PDFParser: 90% 이상
  - StructureBuilder: 90% 이상
  - SummaryService: 90% 이상

## Common Pitfalls

### ❌ 피해야 할 것

1. **E2E 테스트에서 서비스 직접 호출 (백그라운드 작업 우회)**:
```python
# BAD - 프로덕션 플로우와 다른 방식
def test_e2e_pdf_parsing(self, e2e_client, db_session):
    response = e2e_client.post("/api/books/upload", files={"file": f})
    book_id = response.json()["book_id"]
    
    # ❌ 서비스를 직접 호출하여 백그라운드 작업 우회
    parsing_service = ParsingService(db_session)
    book = parsing_service.parse_book(book_id)  # 프로덕션 플로우와 다름
    
    # ✅ GOOD: 실제 HTTP 요청으로 상태 확인하고 백그라운드 작업 완료 대기
    while True:
        response = e2e_client.get(f"/api/books/{book_id}")
        if response.json()["status"] == "parsed":
            break
        time.sleep(2)
```

2. **E2E 테스트에서 Mock 사용**:
```python
# BAD - E2E 테스트에서 모킹
@patch('backend.parsers.upstage_api_client.requests.post')
def test_e2e_full_pipeline(self, mock_post):  # ❌ Mock 사용 금지
    ...
```

3. **TestClient 사용**:
```python
# BAD - TestClient는 백그라운드 작업이 제대로 실행되지 않음
def test_e2e_pdf_parsing(self, client: TestClient):  # ❌ TestClient 사용 금지
    ...

# GOOD - 실제 서버를 띄워서 httpx.Client 사용
def test_e2e_pdf_parsing(self, e2e_client: httpx.Client):  # ✅
    ...
```

4. **E2E 테스트에서 DB 직접 조회**:
```python
# BAD - 서버와 테스트가 다른 DB를 사용하므로 데이터를 찾을 수 없음
def test_e2e_pdf_parsing(self, e2e_client: httpx.Client, db_session):
    response = e2e_client.post("/api/books/upload", files={"file": f})
    book_id = response.json()["book_id"]
    
    # ❌ 테스트 DB에서 조회 (서버는 실제 파일 DB 사용)
    book = db_session.query(Book).filter(Book.id == book_id).first()
    assert book is not None  # ❌ None 반환 (다른 DB이므로)
    
    # ✅ GOOD: API 응답만 검증 (프로덕션 플로우와 동일)
    book_response = e2e_client.get(f"/api/books/{book_id}")
    assert book_response.status_code == 200
    book_data = book_response.json()
    assert book_data["status"] == "parsed"
```

### ✅ 권장 사항

1. **E2E 테스트는 실제 서버 실행, 실제 데이터만, 프로덕션 플로우와 동일하게**:
```python
# GOOD - 실제 서버 실행, 실제 데이터 사용, 프로덕션 플로우와 동일
@pytest.mark.e2e
def test_full_pipeline_e2e(self, e2e_client: httpx.Client, sample_pdf_path):
    with open(sample_pdf_path, "rb") as f:
        files = {"file": ("sample.pdf", f, "application/pdf")}
        response = e2e_client.post("/api/books/upload", files=files)
    # 백그라운드 작업 완료 대기
```

2. **API 응답만 검증 (DB 직접 조회 금지)**:
```python
# GOOD - API 응답으로만 검증 (서버와 테스트가 다른 DB 사용)
@pytest.mark.e2e
def test_e2e_pdf_parsing(e2e_client: httpx.Client):
    # 업로드
    response = e2e_client.post("/api/books/upload", files={"file": f})
    book_id = response.json()["book_id"]
    
    # 상태 폴링 (백그라운드 작업 완료 대기)
    while True:
        response = e2e_client.get(f"/api/books/{book_id}")
        if response.json()["status"] == "parsed":
            break
        time.sleep(2)
    
    # ✅ API 응답만 검증 (DB 직접 조회 금지)
    book_data = e2e_client.get(f"/api/books/{book_id}").json()
    assert book_data["status"] == "parsed"
    assert book_data["page_count"] > 0
```

## References

- Backend API rules: `.cursor/rules/backend-api-design.mdc`
- Backend PDF parsing: `.cursor/rules/backend-pdf-parsing.mdc`
- Project workflow: `.cursor/rules/project-workflow.mdc`
- TODOs.md: Phase별 테스트 요구사항
- pytest 공식 문서: https://docs.pytest.org/
