# PRD: 도서 PDF 구조 분석 & 본문/챕터 서머리 서비스

## 1. 제품 개요

도서 PDF 파일을 업로드하면, 자동으로 **책의 구조(본문 시작, 챕터 경계 등)** 를 파악하고  
이를 기반으로 **페이지별 서머리**와 **챕터별 서머리**를 생성·제공하는 웹 서비스.

- 입력: 사용자가 업로드한 도서 PDF
- 처리:
  - UpstageAPIClient `document-digitization`을 통한 PDF 파싱
  - CORE_LOGIC 기반 책 구조 분석 (본문/챕터 경계 파악)
  - LLM을 활용한 페이지별 및 챕터별 요약 생성
  - 결과/메타데이터는 로컬 SQLite DB에 저장
- 출력:
  - 페이지별 서머리 리스트 및 상세 화면
  - 챕터별 서머리 리스트 및 상세 화면
  - 구조 트리(TOC 형태) 및 책 메타 정보

> 참고: 선행 PRD(books-assistant) 및 CORE_LOGIC 문서를 상위 설계 레퍼런스로 삼되,  
> 본 문서에서는 구조 분석 알고리즘 세부 구현은 추상화하여 다룹니다.

---

## 2. 목표 및 비범위

### 2.1 목표

1. **책 구조 자동 파악**
   - 본문 시작 페이지, 목차/서문/부록 등 구분
   - 챕터/섹션의 시작·끝 페이지 추론
2. **페이지 단위 요약 제공**
   - 각 페이지의 핵심 내용을 2~4문장(또는 bullet) 수준으로 요약
3. **챕터 단위 요약 제공**
   - 챕터에 포함된 페이지 요약을 통합·정제한 상위 요약 제공
4. **결과 재조회/재활용 가능**
   - SQLite에 저장하여, 동일 PDF 재업로드 시 재처리 없이 바로 결과 제공

### 2.2 비범위(이번 버전에서 제외)

- 독자 질의응답(Q&A) 챗봇 기능
- 여러 권을 통합한 지식 그래프/KB 구축
- 협업/주석/공유 기능
- 복잡한 권한 관리, 멀티 유저 SaaS 수준의 계정 시스템

---

## 3. 사용자 및 주요 사용 시나리오

### 3.1 주요 사용자

- 도서/논문을 빠르게 훑어보고 싶은 지식 노동자
- 교재/전문서의 구조를 분석해 학습 계획을 세우려는 학습자
- 도서 큐레이션/요약 서비스를 준비하는 기획자 및 PM

### 3.2 대표 시나리오

1. **빠른 구조/요약 파악**
   - 사용자가 PDF 업로드 →  
     시스템이 구조 분석 + 서머리 생성 →  
     사용자는 챕터 구조/페이지 요약을 훑어보며 책의 전체 윤곽 파악

2. **특정 챕터 집중 학습**
   - 사용자가 챕터 리스트에서 특정 챕터 선택 →  
     챕터 요약 + 해당 챕터에 포함된 페이지별 요약을 순차적으로 확인

3. **재접속 시 결과 재사용**
   - 과거에 업로드한 책 목록에서 특정 책 선택 →  
     기존 구조 및 요약 결과를 즉시 조회 (DB 캐시 활용)

---

## 4. 전체 구조: 입력–처리–출력(IPO)

### 4.1 입력(Input)

- **도서 PDF 파일**
  - 필수: 파일(최대 용량 및 페이지 수 제한 TBD)
  - 선택: 책 제목, 저자, 출판연도 등 메타정보(입력 없을 시 추후 보완 가능)
- **사용자 설정 (1차 버전은 최소화)**
  - 요약 언어 (예: 원문 언어 기준 / 한국어 강제 / 영어 강제 등, 기본값: 원문 언어 추정)
  - 요약 길이 프리셋(짧게/기본/길게, 기본값: 기본)

### 4.2 처리(Process)

1. **PDF 업로드 & 기본 메타 생성**
   - 프론트엔드에서 파일 업로드
   - 서버:
     - 파일을 임시 저장 디렉토리에 저장
     - `books` 테이블에 레코드 생성 (status: `uploaded`)

2. **문서 디지타이제이션 (Upstage `document-digitization`)**
   - 입력: PDF 파일 경로
   - 출력(예시):
     - 페이지별 텍스트
     - 레이아웃 블록 정보 (단락/머리말/꼬리말/페이지 번호 등)
   - 서버:
     - 결과를 `pages`, `page_blocks` 등 관련 테이블로 분해하여 SQLite에 저장
     - 책 상태를 `parsed`로 업데이트

3. **구조 분석 (CORE_LOGIC 사용)**  
   > 내부 알고리즘(LLM 프롬프트, 히ュー리스틱 등)은 `CORE_LOGIC.md`에 정의된 로직 사용.  
   > 여기서는 모듈/입출력 중심으로만 기술.

   - 입력:
     - 페이지별 텍스트
     - 각 페이지의 상단 텍스트, 레이아웃, 페이지 번호 등
   - 핵심 역할:
     - 본문 시작 페이지 추론
     - 챕터/섹션 헤딩 추출 및 경계(page range) 정의
     - 앞/뒷부분(서문, 감사의 글, 참고문헌, 부록 등) 구분
   - 출력:
     - `book_structure` (JSON 혹은 테이블 구조):
       - `chapters`: `chapter_id`, `title`, `start_page`, `end_page`, `order`, `section_type`(본문/부록 등)
   - 서버:
     - 구조 결과를 `chapters` 테이블(또는 구조 저장용 JSON 컬럼)에 저장
     - 책 상태를 `structured`로 업데이트

4. **페이지별 서머리 생성**
   - 대상 페이지 선정:
     - 기본: 본문 페이지 범위만 우선 처리 (서문/참고문헌은 옵션)
   - 각 페이지에 대해:
     - LLM에 전달할 입력 텍스트 구성:
       - 해당 페이지의 전체 텍스트(토큰 제한에 맞게 적절히 잘라내기)
       - 필요 시 **책 컨텍스트** 일부(예: 책 제목, 저자, 챕터 타이틀 등)
     - LLM 호출 → 2~4문장 또는 bullet 형태 요약 반환
   - 결과:
     - `page_summaries` 테이블에 저장:
       - `book_id`, `page_number`, `summary_text`, `lang`, `created_at`
   - 책 상태:
     - 페이지 요약 완료 시 `page_summarized` 등으로 업데이트

5. **챕터별 서머리 생성**
   - 각 챕터에 대해:
     - 챕터에 속한 페이지들의 텍스트 또는 페이지 요약들을 집계
     - LLM에 입력:
       - (옵션 A) 해당 챕터의 원문 텍스트(축약본) + "챕터 전체를 요약" 프롬프트
       - (옵션 B) 페이지 요약 리스트를 입력값으로 사용하여 상위 요약 생성
     - 챕터의 핵심 메시지, 주요 논지/구성 요소를 1~3단락으로 요약
   - 결과:
     - `chapter_summaries` 테이블에 저장:
       - `book_id`, `chapter_id`, `chapter_title`, `summary_text`, `lang`, `created_at`
   - 책 상태:
     - 챕터 요약 완료 시 `summarized` 등 최종 상태로 업데이트

6. **에러 처리 & 재시도**
   - Upstage API 실패 시:
     - 해당 책 status를 `error_parsing`으로, 에러 메시지 로그 저장
   - LLM 요약 실패 시:
     - 해당 페이지/챕터 status를 `error_summarizing`으로 표시
     - UI에서 “요약 재시도” 버튼 제공 (후속 버전 고려)

### 4.3 출력(Output)

- **UI 출력**
  - 책 리스트 화면
    - 업로드된 책 목록, 처리 상태(display: uploaded/parsed/structured/summarized/error)
  - 책 상세 화면
    - 책 메타정보 (제목, 저자, 페이지 수 등)
    - 구조 트리(챕터 리스트)
    - 챕터 선택 시:
      - 챕터 요약(상단)
      - 해당 챕터 페이지별 요약 리스트(하단)
    - 페이지 상세(선택 시):
      - 페이지 원문(텍스트 혹은 이미지)
      - 페이지 요약
- **데이터/Export (후속 단계 고려)**
  - 책 구조 및 요약 내용을 JSON/Markdown으로 다운로드
  - 간단한 CSV (page_number | chapter | page_summary 등) 추출

---

## 5. 시스템 구성 및 아키텍처 개요

### 5.1 주요 컴포넌트

1. **Web 프론트엔드**
   - 역할:
     - PDF 업로드
     - 처리 상태 표시
     - 구조/요약 결과 조회 UI
   - 기술: (예시) React/Next.js 등 – 구체 스택은 간단히만 언급, PRD 레벨에서는 추상화

2. **백엔드 API 서버**
   - 역할:
     - 파일 업로드 처리
     - Upstage API 호출
     - CORE_LOGIC 기반 구조 분석 모듈 호출
     - LLM 요약 모듈 호출
     - SQLite DB CRUD
   - 기술: Python/FastAPI 또는 Node/Express 등 (구체 언어는 추후 결정 가능)

3. **문서 디지타이제이션 모듈**
   - UpstageAPIClient `document-digitization` 래퍼
   - API 키 관리, 재시도 로직, 응답 포맷 표준화

4. **책 구조 분석 모듈 (CORE_LOGIC 연동)**
   - `CORE_LOGIC.md`에 정의된 LLM+규칙 기반 구조 분석 로직을 모듈화하여 호출
   - 입력/출력 인터페이스만 PRD에서 정의, 상세 프롬프트는 CORE_LOGIC에 위임

5. **요약 모듈 (LLM Summarizer)**
   - 페이지/챕터 요약을 위한 공통 LLM 호출 인터페이스
   - 모델/온도/토큰 길이 등은 설정 파일로 분리

6. **SQLite DB**
   - 로컬 파일 기반 DB
   - 개발/로컬 환경에서 쉽게 사용 가능하도록 선택
   - 추후 RDBMS(Supabase 등)로 교체 가능하도록 추상화 레이어 고려

---

## 6. 데이터 모델 (SQLite)

> 실제 스키마는 구현 단계에서 구체화. 여기서는 핵심 엔티티 및 관계만 정의.

### 6.1 `books` 테이블

- `id` (PK)
- `title`
- `author`
- `source_file_path`
- `page_count`
- `status` (enum: uploaded, parsed, structured, page_summarized, summarized, error_*)
- `created_at`
- `updated_at`

### 6.2 `pages` 테이블

- `id` (PK)
- `book_id` (FK → books.id)
- `page_number` (integer)
- `raw_text` (text)
- `metadata` (JSON; 레이아웃/블록 정보 등)
- `created_at`

### 6.3 `chapters` 테이블

- `id` (PK)
- `book_id` (FK)
- `title`
- `order_index`
- `start_page` (integer)
- `end_page` (integer)
- `section_type` (본문, 서문, 부록 등 구분용, optional)
- `created_at`

### 6.4 `page_summaries` 테이블

- `id` (PK)
- `book_id` (FK)
- `page_id` (FK → pages.id, 또는 page_number와 같이 저장)
- `page_number`
- `summary_text`
- `lang`
- `created_at`

### 6.5 `chapter_summaries` 테이블

- `id` (PK)
- `book_id` (FK)
- `chapter_id` (FK → chapters.id)
- `summary_text`
- `lang`
- `created_at`

### 6.6 (옵션) `logs` / `tasks` 테이블

- LLM 호출 로그, 에러 로그, 재시도 정보 저장용

---

## 7. 주요 API 및 화면 흐름

### 7.1 API (개략)

1. `POST /api/books/upload`
   - 요청: PDF 파일, 선택 메타 정보
   - 응답: `book_id`, 초기 status (`uploaded`)
   - 후속: 비동기 작업 큐 또는 백그라운드 작업으로 파싱/요약 진행

2. `GET /api/books`
   - 요청: (옵션) 페이지네이션, 검색어
   - 응답: 책 리스트 + 상태

3. `GET /api/books/{book_id}`
   - 응답: 책 메타 + 구조(챕터 리스트) + 처리 상태

4. `GET /api/books/{book_id}/pages`
   - 응답: 페이지 번호, 각 페이지 요약(있는 경우)

5. `GET /api/books/{book_id}/chapters`
   - 응답: 챕터 리스트 + 각 챕터 요약(있는 경우)

6. `GET /api/books/{book_id}/chapters/{chapter_id}`
   - 응답: 챕터 상세(요약 + 해당 페이지 리스트/요약)

> CORE_LOGIC 및 LLM 호출을 직접 노출하는 API는 내부용으로만 사용.

### 7.2 화면 플로우

1. **책 목록 페이지**
   - [업로드 버튼]
   - [책 카드 리스트: 제목, 상태, 업로드일]

2. **책 업로드 플로우**
   - 파일 선택 → 업로드 진행률 표시 → 업로드 성공 시 상세 페이지로 이동(처리 중 상태 표시)

3. **책 상세 페이지**
   - 상단: 제목, 저자, 상태, 총 페이지 수
   - 좌측: 챕터 구조 트리
   - 우측:
     - 선택된 챕터 요약
     - 페이지 리스트 (요약 미리보기)

4. **페이지 상세 모달/페이지**
   - 원문 텍스트(또는 스냅샷 이미지)
   - 페이지 요약

---

## 8. 품질 기준 및 비기능 요구사항

1. **정확도**
   - 구조 분석:
     - 본문 시작/종료, 챕터 경계 판단이 사람이 보기에 “대략 타당한” 수준
     - 오류가 발생하더라도 전체 플로우가 깨지지 않고 요약은 제공 가능해야 함
   - 요약:
     - 원문 내용 기반의 요약이어야 하며, 과도한 추측/추론 최소화

2. **성능**
   - 중간 길이 도서(예: 300페이지) 기준:
     - 전체 파이프라인(파싱+구조 분석+요약) 완료까지의 시간은 실험 후 가이드라인 설정
   - 파이프라인 진행 상황을 status로 확인 가능해야 함

3. **안정성**
   - Upstage/LLM 장애 시에도, 이미 완료된 결과는 정상 조회 가능
   - SQLite 파일 손상 방지를 위한 기본적인 예외 처리 및 백업 전략(개발 환경 기준 간단 버전)

4. **보안/프라이버시**
   - 로컬 개발 환경 기준:
     - 업로드된 PDF 및 파생 데이터는 로컬 스토리지/SQLite에만 존재
   - 상용화 시:
     - 추후 별도의 보안 요구사항 및 데이터 보존 정책 수립

---

## 9. 향후 확장 방향 (레퍼런스 수준)

- 구조 분석 정확도를 높이기 위한 사용자 피드백 기반 수정 UI (챕터 시작/끝 수동 조정)
- 페이지/챕터 서머리를 기반으로 한 Q&A 챗봇
- 다권(多卷) 분석 및 분야별 지식베이스 자동 구축
- SQLite → 클라우드 RDB(Postgres+Supabase 등)로 이관

---

## 10. 정리

본 서비스는:

1. **PDF → 구조화된 책 데이터** (페이지/챕터)
2. **구조화된 데이터 → 페이지 및 챕터 요약**

이라는 두 축을 핵심으로 하며,  
문서 디지타이제이션(Upstage) + CORE_LOGIC 기반 구조 분석 + LLM 요약을 하나의 파이프라인으로 묶고,  
결과를 SQLite에 저장하여 재사용/재조회 가능한 **“도서 구조+요약 뷰어”**를 제공하는 것을 1차 목표로 한다.
