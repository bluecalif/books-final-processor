# 구조 분석 로직 설명

이 문서는 구조 분석 모듈의 각 단계별 로직을 자연어로 명확하게 설명합니다.

## 1. 본문 탐지 구조 (ContentBoundaryDetector)

### 1.1 전체 흐름

본문 탐지는 `ContentBoundaryDetector.detect_boundaries()` 메서드에서 수행됩니다.

**단계 1: 본문 시작 페이지 탐지**
- `_detect_main_start()` 메서드 호출
- 모든 페이지(3페이지부터, 표지 제외)에 대해 본문 시작 가능성 점수 계산
- 가장 높은 점수를 가진 페이지를 본문 시작 페이지로 선택

**단계 2: 종문 시작 페이지 탐지**
- `_detect_notes_start()` 메서드 호출
- 본문 시작 페이지 이후의 모든 페이지에 대해 종문 시작 가능성 확인
- END_KEYWORDS 매칭 또는 패턴 매칭으로 종문 시작 페이지 탐지

**단계 3: 경계 확정**
- 서문(start): 1페이지 ~ (본문 시작 - 1)페이지
- 본문(main): 본문 시작 페이지 ~ (종문 시작 - 1)페이지
- 종문(end): 종문 시작 페이지 ~ 마지막 페이지

### 1.2 본문 시작 점수 계산 로직 (`_calculate_main_start_score`)

각 페이지에 대해 다음 요소들을 종합하여 점수를 계산합니다:

**1.2.1 START_KEYWORDS 매칭 (가중치: 높음)**
- 페이지의 모든 요소 텍스트에서 START_KEYWORDS 목록의 키워드를 검색
- 매칭된 키워드가 있으면 점수에 큰 가중치 부여
- 키워드 예시: "작가", "저자", "서문", "머리말", "차례", "목차" 등
- **의도**: 이러한 키워드가 있는 페이지는 본문 시작 이전의 서문 영역임을 나타냄

**1.2.2 MAIN_START_PATTERNS 매칭 (가중치: 매우 높음)**
- 페이지의 모든 요소 텍스트에서 MAIN_START_PATTERNS 목록의 패턴을 검색
- 매칭된 패턴이 있으면 점수에 매우 큰 가중치 부여
- 패턴 예시:
  - `제\s*1\s*장` (제1장)
  - `CHAPTER\s+[1I]` (Chapter 1, Chapter I)
  - `^1\.\s+[가-힣a-zA-Z]` (1. 제목 형식)
- **의도**: 첫 번째 챕터가 시작되는 패턴을 찾아 본문 시작을 정확히 탐지

**1.2.3 페이지 상단 요소 확인 (가중치: 중간)**
- 페이지의 요소들 중 y0 좌표가 가장 작은 요소(페이지 상단)를 확인
- 상단 요소의 텍스트가 본문 시작 패턴과 일치하면 점수 가중치 부여
- **의도**: 챕터 제목은 보통 페이지 상단에 위치하므로, 상단 요소가 중요함

**1.2.4 큰 폰트 크기 확인 (가중치: 낮음)**
- 요소의 font_size가 LARGE_FONT_THRESHOLD(16px) 이상이면 점수 가중치 부여
- **의도**: 챕터 제목은 보통 큰 폰트로 표시됨

**1.2.5 본문 텍스트 길이 확인 (가중치: 낮음)**
- 페이지의 전체 텍스트 길이가 MIN_PARAGRAPH_LENGTH(100자) 이상이면 점수 가중치 부여
- **의도**: 본문은 서문보다 텍스트가 많음

**1.2.6 점수 종합**
- 위의 모든 요소의 점수를 가중치에 따라 합산
- 가장 높은 점수를 가진 페이지를 본문 시작 페이지로 선택
- 기본값: 최소 3페이지부터 시작 (표지 제외)

### 1.3 종문 시작 탐지 로직 (`_detect_notes_start`)

**3단계 계층적 필터링:**

**Phase 1: Footer 요소 우선 검사**
- 페이지 하단(footer) 영역의 요소들을 우선 검사
- END_KEYWORDS 목록의 키워드를 단어 경계 매칭으로 검색
- 매칭되면 해당 페이지를 종문 시작으로 확정

**Phase 2: 제목 형태 Element 검사**
- 페이지 상단의 짧은 텍스트 + 큰 폰트 요소를 검사
- END_KEYWORDS 목록의 키워드를 단어 경계 매칭으로 검색
- 매칭되면 해당 페이지를 종문 시작으로 확정

**Phase 3: 전체 텍스트 검사 (Fallback)**
- 위 두 단계에서 매칭되지 않으면, 페이지의 전체 텍스트를 검사
- END_KEYWORDS 목록의 키워드를 단어 경계 매칭으로 검색
- 매칭되면 해당 페이지를 종문 시작으로 확정

**END_KEYWORDS 예시**: "참고문헌", "부록", "색인", "references", "appendix" 등

---

## 2. 챕터 탐지 구조 (ChapterDetector)

### 2.1 전체 흐름

챕터 탐지는 `ChapterDetector.detect_chapters()` 메서드에서 수행됩니다.

**단계 1: 챕터 제목 후보 탐지**
- 본문 영역(main_pages)의 모든 페이지를 순회
- 각 페이지의 모든 요소에 대해 `_find_chapter_candidates()` 호출
- CHAPTER_PATTERNS 목록의 패턴으로 텍스트 매칭 시도
- 매칭되면 챕터 후보로 등록

**단계 2: 점수 기반 필터링**
- 각 후보에 대해 `_calculate_chapter_score()`로 점수 계산
- SCORE_THRESHOLD(55점) 이상인 후보만 챕터로 확정
- 점수 미달 후보는 제외

**단계 3: 품질 검증 및 정제**
- `_validate_and_refine_chapters()` 호출
- 챕터 간 최소 간격(MIN_CHAPTER_SPACING=3페이지) 확인
- 각 챕터의 시작/끝 페이지 범위 계산
- 최종 챕터 목록 반환

### 2.2 챕터 후보 탐지 로직 (`_find_chapter_candidates`)

**2.2.1 요소 순회**
- 페이지의 모든 요소(elements)를 순회
- 각 요소의 텍스트를 추출

**2.2.2 패턴 매칭**
- CHAPTER_PATTERNS 목록의 각 패턴에 대해 순차적으로 매칭 시도:
  1. `korean_chapter_full`: `^제\s*(\d+)\s*장` (제1장, 제2장 등) - base_score: 50
  2. `korean_chapter_short`: `^(\d+)\s*장$` (1장, 2장 등) - base_score: 50
  3. `korean_part`: `^제\s*(\d+)\s*부` (제1부 등) - base_score: 55
  4. `english_chapter`: `^CHAPTER\s+(\d+)` (CHAPTER 1 등) - base_score: 50
  5. `english_part`: `^Part\s+(\d+)` (Part 1 등) - base_score: 55
  6. `numbered_title`: `^(\d+)\.\s+([가-힣a-zA-Z].{3,})` (1. 제목 형식) - base_score: 35

**2.2.3 매칭 성공 시**
- 패턴에서 챕터 번호 추출
- base_score를 초기 점수로 설정
- `_calculate_chapter_score()` 호출하여 최종 점수 계산

### 2.3 챕터 점수 계산 로직 (`_calculate_chapter_score`)

**2.3.1 기본 점수 (base_score)**
- 패턴 매칭 시 해당 패턴의 base_score를 기본 점수로 사용
- 패턴별 base_score:
  - 한글 챕터/영어 챕터: 50점
  - 한글 부/영어 Part: 55점
  - 번호 제목: 35점

**2.3.2 위치 보너스 (y0 좌표)**
- 요소의 y0 좌표(페이지 상단에서의 거리)가 작을수록 높은 보너스
- 페이지 상단에 가까울수록 챕터 제목일 가능성이 높음
- 보너스 계산: `(1.0 - y0) * 20` (최대 20점)

**2.3.3 폰트 크기 보너스**
- 요소의 font_size가 LARGE_FONT_THRESHOLD(16px) 이상이면 보너스 부여
- 보너스 계산: `(font_size - 16) * 2` (최대 10점)

**2.3.4 카테고리 보너스**
- 요소의 category가 'heading' 또는 'title'이면 보너스 부여
- 보너스: 5점

**2.3.5 최종 점수**
- 기본 점수 + 위치 보너스 + 폰트 크기 보너스 + 카테고리 보너스
- SCORE_THRESHOLD(55점) 이상인 후보만 챕터로 확정

### 2.4 챕터 검증 및 정제 로직 (`_validate_and_refine_chapters`)

**2.4.1 챕터 간 최소 간격 확인**
- 챕터들을 페이지 번호 순으로 정렬
- 인접한 챕터 간 페이지 간격이 MIN_CHAPTER_SPACING(3페이지) 이상인지 확인
- 간격이 너무 좁으면 후보 중 하나를 제외 (점수가 낮은 것 제외)

**2.4.2 챕터 범위 계산**
- 각 챕터의 시작 페이지는 탐지된 페이지 번호
- 각 챕터의 끝 페이지는 다음 챕터의 시작 페이지 - 1
- 마지막 챕터의 끝 페이지는 본문 끝 페이지

**2.4.3 최종 챕터 목록 반환**
- 검증을 통과한 챕터들만 반환
- 각 챕터 정보: id, number, title, start_page, end_page, score, detection_method

---

## 3. LLM 보정 로직 (LLMStructureRefiner)

### 3.1 전체 흐름

LLM 보정은 `LLMStructureRefiner.refine_structure()` 메서드에서 수행됩니다.

**단계 1: 컨텍스트 구축**
- 휴리스틱 구조를 기반으로 LLM에게 제공할 컨텍스트 구축
- `_build_context_for_llm()` 메서드 호출

**단계 2: 프롬프트 생성**
- 컨텍스트와 휴리스틱 구조를 바탕으로 LLM 프롬프트 생성
- `_build_prompt()` 메서드 호출

**단계 3: LLM 호출**
- OpenAI API (gpt-4.1-mini) 호출
- JSON 형식 응답 요청

**단계 4: 응답 파싱 및 검증**
- LLM 응답을 Pydantic 모델(LLMStructureSuggestion)로 파싱
- `_parse_llm_response()` 메서드 호출

**단계 5: Fallback 처리**
- LLM 호출 실패 또는 파싱 실패 시
- `_fallback_to_heuristic()` 메서드로 휴리스틱 구조를 그대로 반환

### 3.2 컨텍스트 구축 로직 (`_build_context_for_llm`)

**3.2.1 페이지 토플라인 체인 생성**
- `_build_page_toplines_chain()` 메서드 호출
- 각 페이지의 상단 요소(y0가 가장 작은 요소)에서 텍스트 추출
- 각 페이지당 최대 50자만 추출하여 체인 형식으로 연결
- 형식: `p{page_number}: {텍스트_50자}`
- **의도**: LLM이 페이지별 핵심 정보를 빠르게 파악할 수 있도록 함

**3.2.2 휴리스틱 구조 정보 포함**
- 휴리스틱 구조에서 탐지된 챕터 정보 포함
- 본문 시작/끝 페이지 정보 포함
- **의도**: LLM이 휴리스틱의 탐지 결과를 참고하여 보정할 수 있도록 함

**3.2.3 샘플 페이지 정보 포함**
- 본문 시작 주변 페이지의 상세 텍스트 샘플 포함
- **의도**: LLM이 본문 시작 지점을 정확히 판단할 수 있도록 함

### 3.3 프롬프트 생성 로직 (`_build_prompt`)

**3.3.1 프롬프트 구조**
1. **역할 정의**: LLM에게 구조 분석 전문가 역할 부여
2. **입력 데이터 설명**: 
   - 페이지 토플라인 체인 (각 페이지 상단 50자)
   - 휴리스틱 구조 탐지 결과
   - 샘플 페이지 상세 텍스트
3. **작업 지시**:
   - 본문 시작/끝 페이지 재확인
   - 챕터 경계 재확인 및 누락된 챕터 탐지
   - 챕터 제목 추출
4. **출력 형식**: JSON 형식으로 구조화된 응답 요청

**3.3.2 휴리스틱 구조 기반 보정 지시**
- 휴리스틱이 탐지한 챕터 정보를 제공하되, LLM이 이를 검증하고 보정하도록 지시
- 누락된 챕터가 있으면 탐지하도록 지시
- 잘못 탐지된 챕터가 있으면 제외하도록 지시

### 3.4 LLM 응답 파싱 및 검증 (`_parse_llm_response`)

**3.4.1 JSON 파싱**
- LLM 응답을 JSON으로 파싱
- Pydantic 모델(LLMStructureSuggestion)로 검증

**3.4.2 응답 구조**
```python
{
    "main_start_page": int,
    "main_end_page": Optional[int],
    "chapters": [
        {
            "number": Optional[int],
            "title": str,
            "start_page": int,
            "end_page": int
        }
    ],
    "notes_pages": List[int],
    "issues": Optional[str]  # LLM이 발견한 문제점 설명
}
```

**3.4.3 검증 실패 시**
- 파싱 실패 또는 검증 실패 시
- `_fallback_to_heuristic()` 호출하여 휴리스틱 구조 반환

### 3.5 Fallback 로직 (`_fallback_to_heuristic`)

**3.5.1 휴리스틱 구조 변환**
- 휴리스틱 구조 형식을 LLM 구조 형식으로 변환
- 휴리스틱 구조의 `main.pages[0]`을 `main_start_page`로 변환
- 휴리스틱 구조의 `main.chapters`를 LLM 구조의 `chapters` 형식으로 변환

**3.5.2 반환**
- 변환된 구조를 LLMStructureSuggestion 형식으로 반환
- **의도**: LLM 호출 실패 시에도 휴리스틱 결과를 사용할 수 있도록 함

### 3.6 LLM 보정의 한계

**3.6.1 휴리스틱 의존성**
- LLM은 휴리스틱 구조를 기반으로 보정하므로, 휴리스틱이 잘못 탐지한 정보를 근본적으로 수정하기 어려움
- 예: 휴리스틱이 리스트 항목을 챕터로 오인식하면, LLM도 이를 기반으로 추론하므로 근본적 개선이 어려움

**3.6.2 컨텍스트 제한**
- 페이지 토플라인 체인은 각 페이지당 50자만 제공하므로, 상세한 컨텍스트가 부족할 수 있음
- LLM이 전체 페이지 내용을 보지 못하므로, 정확한 판단이 어려울 수 있음

**3.6.3 패턴 인식 한계**
- LLM이 특정 형식의 챕터 제목("제N장", "[제N강] ...")을 인식하지 못할 수 있음
- 휴리스틱이 제공한 잘못된 정보를 바탕으로 추론하므로, 올바른 챕터를 찾기 어려울 수 있음

---

## 요약

1. **본문 탐지**: START_KEYWORDS와 MAIN_START_PATTERNS를 사용하여 본문 시작 페이지를 점수 기반으로 탐지
2. **챕터 탐지**: CHAPTER_PATTERNS로 텍스트 매칭 후, 점수 기반 필터링 및 검증을 통해 챕터 경계 탐지
3. **LLM 보정**: 휴리스틱 구조를 기반으로 컨텍스트를 구축하고, LLM이 구조를 검증 및 보정하도록 프롬프트 생성

