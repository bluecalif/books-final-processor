# 구조 분석 로직 설명 (Footer 기반)

이 문서는 Footer 기반 구조 분석 모듈의 각 단계별 로직을 자연어로 명확하게 설명합니다.

## 핵심 원칙

1. **Footer 기반 판단**: 모든 구조 판단은 Footer의 구조 판별자를 기준으로 수행
2. **좌측 페이지 우선**: 홀수 페이지(좌측)에 항상 구조 판별자가 나타나므로 이를 기준으로 판단
3. **숫자 기반 챕터 구분**: "제", "장", "강", "part" 등의 특별한 식별자에 구애받지 않고, 숫자를 바탕으로 챕터 구분
4. **LLM 보정 제외**: 휴리스틱 기반 구조 분석만 사용 (LLM 보정 로직 미적용)

---

## 1. Footer 기반 본문 탐지 구조

### 1.1 전체 흐름

본문 탐지는 Footer의 구조 판별자를 기준으로 수행됩니다.

**단계 1: Footer 구조 판별자 추출**
- 모든 홀수 페이지(좌측 페이지)의 Footer에서 구조 판별자 추출
- 구조 판별자: Footer 영역에 나타나는 텍스트 (예: "제1장", "1", "Chapter 1" 등)

**단계 2: 서문/본문/종문 구분**
- Footer 구조 판별자에 숫자가 포함되어 있는지 확인
- 숫자 포함 + 서문 키워드 없음 → 본문 영역
- 숫자 미포함 + 서문 키워드 포함 → 서문 영역
- 숫자 미포함 + 종문 키워드 포함 → 종문 영역

**단계 3: 경계 확정**
- 서문(start): 서문 영역으로 판단된 페이지들
- 본문(main): 본문 영역으로 판단된 페이지들
- 종문(end): 종문 영역으로 판단된 페이지들

### 1.2 Footer 구조 판별자 추출 로직

**1.2.1 홀수 페이지(좌측 페이지) 우선 처리**
- 모든 홀수 페이지(1, 3, 5, 7, ...)의 Footer 영역을 확인
- Footer 영역: 페이지 하단에 위치한 요소들 (category='footer' 또는 y0 좌표가 큰 요소들)

**1.2.2 구조 판별자 텍스트 추출**
- Footer 영역의 모든 요소에서 텍스트 추출
- 구조 판별자 후보: Footer에 나타나는 모든 텍스트
- 우선순위: 페이지 하단에 가까운 요소일수록 높은 우선순위

**1.2.3 구조 판별자 정제**
- 불필요한 공백, 특수문자 제거
- 숫자 포함 여부 확인
- 키워드 포함 여부 확인 (서문/종문 키워드)

### 1.3 서문/본문/종문 구분 로직

**1.3.1 숫자 포함 여부 확인**
- Footer 구조 판별자에 숫자(0-9)가 포함되어 있는지 확인
- 정규식: `\d+` (하나 이상의 숫자)
- **핵심 원칙**: 숫자가 포함되어 있으면 본문 영역으로 판단

**1.3.2 서문 키워드 확인**
- START_KEYWORDS 목록의 키워드가 페이지 전체 텍스트에 포함되어 있는지 확인
- **핵심 원칙**: 숫자 미포함 + 서문 키워드 포함 → 서문 영역
- **서문 키워드 목록**:
  - 한글: "작가", "작가 소개", "저자", "저자 소개", "저자소개", "지은이", "추천", "추천의 글", "추천사", "추천하는 말", "서문", "머리말", "프롤로그", "들어가며", "들어가는 글", "들어가는 말", "처음으로", "작품 소개", "작품소개", "옮긴이", "서론", "감수", "시작하며", "감사의 글", "감사", "헌정", "표지", "판권", "저작권", "차례", "목차"
  - 영어: "author", "about the author", "recommendation", "foreword", "preface", "prologue", "introduction", "acknowledgment", "dedication", "copyright", "contents", "table of contents"
- **판별 순서**:
  1. 홀수 페이지 Footer에서 챕터 표시 판별자(`chapter_marker`) 확인
  2. 없으면 페이지 전체 텍스트에서 START_KEYWORDS 확인
  3. 키워드가 있으면 서문 영역으로 판단

**1.3.3 종문 키워드 확인**
- END_KEYWORDS 목록의 키워드가 Footer 텍스트에 포함되어 있는지 확인 (부분 문자열 매칭)
- **핵심 원칙**: 숫자 미포함 + 종문 키워드 포함 → 종문 영역
- **종문 키워드 목록**:
  - 한글: "맺음말", "맺는 글", "맺는 말", "끝맺음", "나가며", "마치며", "에필로그", "결론", "주", "각주", "미주", "참고 주", "주석", "참고문헌", "참고 문헌", "참고자료", "문헌", "부록", "색인", "용어집", "출판", "출판사", "출판정보", "판권", "출처", "해설", "감사", "닫는 글", "도서정보", "찾아보기", "감수"
  - 영어: "epilogue", "conclusion", "closing", "endnote", "endnotes", "notes", "footnote", "references", "bibliography", "appendix", "appendices", "index", "glossary", "publisher", "publishing"
- **주의사항**:
  - 부분 문자열 매칭으로 인한 오탐지 가능 (예: "자주" 안의 "주")
  - 전체 Footer 텍스트 확인 및 로깅으로 디버깅 지원
- **판별 순서**:
  1. 본문 시작 페이지 이후의 홀수 페이지부터 역순 확인
  2. Footer 텍스트에서 END_KEYWORDS 매칭
  3. 매칭되면 종문 시작 페이지로 확정

**1.3.4 구분 규칙**
1. **본문 영역**: Footer 구조 판별자에 숫자 포함 (서문/종문 키워드 없음)
2. **서문 영역**: Footer 구조 판별자에 숫자 미포함 + 서문 키워드 포함
3. **종문 영역**: Footer 구조 판별자에 숫자 미포함 + 종문 키워드 포함
4. **불명확**: 위 조건에 해당하지 않으면 이전 페이지의 영역을 따라감

### 1.4 경계 확정 로직

**1.4.1 서문/본문 경계**
- 서문 영역으로 판단된 마지막 페이지 다음 페이지가 본문 시작
- 또는 본문 영역으로 판단된 첫 페이지가 본문 시작

**1.4.2 본문/종문 경계**
- 본문 영역으로 판단된 마지막 페이지 다음 페이지가 종문 시작
- 또는 종문 영역으로 판단된 첫 페이지가 종문 시작

**1.4.3 짝수 페이지(우측 페이지) 처리**
- 홀수 페이지(좌측)의 구조 판별자를 기준으로 판단
- 짝수 페이지(우측)는 인접한 홀수 페이지와 동일한 영역으로 간주
- 예: 1페이지(홀수)가 서문이면 2페이지(짝수)도 서문
- 예: 3페이지(홀수)가 본문이면 4페이지(짝수)도 본문

---

## 2. Footer 기반 챕터 탐지 구조

### 2.1 전체 흐름

챕터 탐지는 Footer의 구조 판별자에 나타나는 숫자를 기준으로 수행됩니다.

**단계 1: 본문 영역의 Footer 구조 판별자 추출**
- 본문 영역으로 판단된 모든 홀수 페이지의 Footer에서 구조 판별자 추출
- 구조 판별자에서 숫자 추출

**단계 2: 숫자 기반 챕터 구분**
- Footer 구조 판별자에 나타나는 숫자를 기준으로 챕터 구분
- "제", "장", "강", "part" 등의 특별한 식별자는 무시하고, 숫자만 사용
- 예: "제1장" → 숫자 1, "Chapter 2" → 숫자 2, "3" → 숫자 3

**단계 3: 챕터 범위 계산**
- 각 챕터의 시작 페이지는 해당 챕터 번호가 처음 나타나는 홀수 페이지
- 각 챕터의 끝 페이지는 다음 챕터 번호가 나타나는 홀수 페이지 - 1
- 마지막 챕터의 끝 페이지는 본문 끝 페이지

**단계 4: 짝수 페이지(우측 페이지) 처리**
- 홀수 페이지(좌측)의 챕터 구분을 기준으로 판단
- 짝수 페이지(우측)는 인접한 홀수 페이지와 동일한 챕터로 간주
- 예: 3페이지(홀수)가 챕터 1이면 4페이지(짝수)도 챕터 1

### 2.2 Footer 구조 판별자에서 숫자 추출 로직

**2.2.1 본문 영역의 홀수 페이지 순회**
- 본문 영역으로 판단된 모든 홀수 페이지를 순회
- 각 페이지의 Footer 영역에서 구조 판별자 추출

**2.2.2 숫자 추출**
- Footer 구조 판별자 텍스트에서 숫자 추출
- 정규식: `\d+` (하나 이상의 숫자)
- 첫 번째로 나타나는 숫자를 챕터 번호로 사용
- 예: "제1장" → 1, "Chapter 2" → 2, "Chapter2" → 2, "3. 제목" → 3, "3.제목" → 3
- **공백 유무 모두 매칭**: 정규식 패턴에서 `\s*`(0개 이상 공백) 사용하여 "Chapter 1"과 "Chapter1" 모두 인식

**2.2.3 숫자 정제**
- 추출된 숫자가 유효한 챕터 번호인지 확인 (1 이상의 정수)
- 숫자가 없으면 해당 페이지는 챕터 경계가 아님

### 2.3 숫자 기반 챕터 구분 로직

**2.3.1 챕터 번호 추출**
- 각 본문 홀수 페이지의 Footer 구조 판별자에서 숫자 추출
- 추출된 숫자를 챕터 번호로 사용
- **핵심 원칙**: "제", "장", "강", "part" 등의 특별한 식별자는 무시하고, 숫자만 사용

**2.3.2 챕터 경계 탐지**
- 챕터 번호가 변경되는 지점을 챕터 경계로 판단
- 예: 페이지 3에서 숫자 1, 페이지 5에서 숫자 1, 페이지 7에서 숫자 2
  - 챕터 1: 페이지 3, 5 (및 짝수 페이지 4, 6)
  - 챕터 2: 페이지 7부터 (및 짝수 페이지 8부터)

**2.3.3 챕터 번호 연속성 확인**
- 챕터 번호가 연속적으로 증가하는지 확인 (1, 2, 3, 4, ...)
- 번호가 건너뛰어지면 (예: 1, 2, 4) 경고 로그 출력
- 번호가 역순이면 (예: 3, 2, 1) 경고 로그 출력

### 2.4 챕터 범위 계산 로직

**2.4.1 챕터 시작 페이지**
- 각 챕터의 시작 페이지는 해당 챕터 번호가 처음 나타나는 홀수 페이지
- 예: 챕터 1이 페이지 3에서 처음 나타나면, 챕터 1의 시작 페이지는 3

**2.4.2 챕터 끝 페이지**
- 각 챕터의 끝 페이지는 다음 챕터 번호가 나타나는 홀수 페이지 - 1
- 예: 챕터 1이 페이지 3에서 시작하고, 챕터 2가 페이지 7에서 시작하면
  - 챕터 1의 끝 페이지는 6 (페이지 7 - 1)
- 마지막 챕터의 끝 페이지는 본문 끝 페이지

**2.4.3 짝수 페이지(우측 페이지) 포함**
- 홀수 페이지(좌측)의 챕터 구분을 기준으로 판단
- 짝수 페이지(우측)는 인접한 홀수 페이지와 동일한 챕터로 간주
- 예: 챕터 1이 페이지 3(홀수)에서 시작하면, 페이지 4(짝수)도 챕터 1의 시작
- 예: 챕터 1이 페이지 6(짝수)에서 끝나면, 실제로는 페이지 5(홀수)와 6(짝수) 모두 챕터 1

### 2.5 챕터 제목 추출 로직 (선택적)

**2.5.1 챕터 제목 후보 탐지**
- 각 챕터 시작 페이지의 페이지 상단 요소에서 텍스트 추출
- 페이지 상단: y0 좌표가 가장 작은 요소(페이지 맨 위)

**2.5.2 챕터 제목 정제**
- 추출된 텍스트에서 불필요한 공백, 특수문자 제거
- 챕터 번호와 함께 나타나는 텍스트를 챕터 제목으로 사용
- 예: "제1장 의식의 본질" → "의식의 본질"
- 예: "Chapter 2: Introduction" → "Introduction"

**2.5.3 챕터 제목 저장**
- 각 챕터의 제목을 챕터 정보에 포함
- 제목을 추출할 수 없으면 챕터 번호만 사용 (예: "제1장", "Chapter 1")

### 2.6 챕터 판별 키워드 및 방식

**2.6.1 Footer 요소 분류**
- Footer 요소는 3가지로 분류: `chapter_marker`(챕터 표시 판별자), `page_number`(페이지 번호), `other`(기타)
- 분류는 `_classify_footer_element()` 메서드에서 수행

**2.6.2 패턴 기반 판별**
- 정규식 패턴으로 챕터 표시 판별자 인식
- **챕터 패턴 목록**:
  - `제\s*\d+\s*[장강부]`: "제1장", "제 1 장", "제1강", "제1부" (공백 유무 모두 매칭)
  - `CHAPTER\s*\d+`: "Chapter 1", "Chapter1" (공백 유무 모두 매칭, 대소문자 무시)
  - `Part\s*\d+`: "Part 1", "Part1" (공백 유무 모두 매칭, 대소문자 무시)
  - `^\d+\s*[장강부]`: "1장", "1 장" (공백 유무 모두 매칭)
  - `^\d+\.\s*[가-힣]`: "1. 제목", "1.제목" (공백 유무 모두 매칭)
- 패턴 매칭되면 → `chapter_marker`로 분류

**2.6.3 위치 기반 판별**
- `x0 < 0.05`: 왼쪽 끝 영역 (페이지 번호 후보)
- 페이지 번호 패턴 확인: 숫자만 있는 경우
- 위치 + 페이지 번호 패턴 → `page_number`로 분류

**2.6.4 폰트 크기 기반 판별**
- 큰 폰트(16px 이상)는 챕터 표시 후보
- 폰트 크기만으로는 판별하지 않고, 패턴과 함께 고려

**2.6.5 분류 우선순위**
1. **패턴 매칭** → `chapter_marker` (최우선)
2. **위치 + 페이지 번호 패턴** → `page_number`
3. **기타** → `other`

**2.6.6 본문 시작 페이지 탐지 개선**
- `_detect_main_start_improved()`: 챕터 표시 판별자(`chapter_marker`) 기준 탐지
  - 기존: Footer에 숫자만 있으면 본문으로 판단
  - 개선: Footer에서 `chapter_marker` 분류된 요소 확인
  - 서문 키워드가 있는 페이지는 제외

**2.6.7 종문 시작 페이지 탐지 개선**
- `_detect_notes_start_improved()`: 부분 문자열 오탐지 방지
  - 기존: `keyword in footer_text` (부분 문자열 매칭)
  - 개선: 전체 Footer 텍스트 확인 + 매칭된 키워드 로깅
  - 효과: "자주" 안의 "주" 오탐지 방지

---

## 3. LLM 보정 로직 제외

### 3.1 LLM 보정 미적용

**3.1.1 휴리스틱 구조만 사용**
- Footer 기반 휴리스틱 구조 분석 결과를 그대로 사용
- LLM 보정 단계를 거치지 않음

**3.1.2 구조 후보 반환**
- API 응답에서 `auto_candidates`는 Footer 기반 휴리스틱 구조만 포함
- `label: "heuristic_v1"` 또는 `label: "footer_based_v1"` 형식으로 반환
- LLM 보정 구조(`label: "llm_v2"`)는 포함하지 않음

### 3.2 구조 분석 파이프라인

**3.2.1 단일 단계 구조 분석**
1. PDF 파싱 (Upstage API)
2. Footer 기반 본문 탐지 (ContentBoundaryDetector)
3. Footer 기반 챕터 탐지 (ChapterDetector)
4. 최종 구조 반환

**3.2.2 LLM 보정 단계 제거**
- `LLMStructureRefiner.refine_structure()` 호출 제거
- `StructureService.get_structure_candidates()`에서 LLM 보정 로직 제거

---

## 4. 구현 세부 사항

### 4.1 Footer 영역 식별

**4.1.1 Footer 요소 필터링**
- 요소의 `category`가 `'footer'`인 경우
- 또는 요소의 `bbox.y0` 좌표가 0.9 이상인 경우 (정규화된 좌표, 페이지 하단 10% 영역)
- **조건 강화**: 기존 0.8(하단 20%)에서 0.9(하단 10%)로 강화하여 종문 오탐지 방지
- **OR 관계**: 두 조건 중 하나만 만족하면 Footer 요소로 인식

**4.1.2 Footer 텍스트 추출**
- Footer 영역의 모든 요소에서 텍스트 추출
- 여러 요소가 있으면 텍스트를 공백으로 연결
- 구조 판별자는 Footer 텍스트 전체 또는 일부

### 4.2 숫자 추출 및 정제

**4.2.1 숫자 추출 정규식**
- 기본: `\d+` (하나 이상의 숫자)
- 첫 번째로 나타나는 숫자를 챕터 번호로 사용
- 예: "제1장" → `re.search(r'\d+', "제1장")` → `1`

**4.2.2 숫자 정제**
- 추출된 숫자가 유효한 챕터 번호인지 확인 (1 이상의 정수)
- 숫자가 없으면 해당 페이지는 챕터 경계가 아님
- 숫자가 여러 개 있으면 첫 번째 숫자를 사용

### 4.3 챕터 번호 매핑

**4.3.1 페이지 → 챕터 번호 매핑**
- 각 본문 홀수 페이지에 대해 챕터 번호 추출
- 페이지 번호와 챕터 번호를 매핑: `{page_number: chapter_number}`
- 예: `{3: 1, 5: 1, 7: 2, 9: 2, 11: 3, ...}`

**4.3.2 짝수 페이지 처리**
- 짝수 페이지는 인접한 홀수 페이지의 챕터 번호를 사용
- 예: 페이지 4(짝수)는 페이지 3(홀수)의 챕터 번호를 사용
- 예: 페이지 6(짝수)는 페이지 5(홀수)의 챕터 번호를 사용

### 4.4 챕터 범위 계산

**4.4.1 챕터 시작 페이지 계산**
- 각 챕터 번호에 대해 처음 나타나는 홀수 페이지를 시작 페이지로 사용
- 예: 챕터 1이 페이지 3에서 처음 나타나면, 시작 페이지는 3

**4.4.2 챕터 끝 페이지 계산**
- 각 챕터 번호에 대해 마지막으로 나타나는 홀수 페이지를 찾음
- 다음 챕터 번호가 나타나는 홀수 페이지 - 1을 끝 페이지로 사용
- 예: 챕터 1이 페이지 3, 5에서 나타나고, 챕터 2가 페이지 7에서 나타나면
  - 챕터 1의 끝 페이지는 6 (페이지 7 - 1)

**4.4.3 마지막 챕터 처리**
- 마지막 챕터의 끝 페이지는 본문 끝 페이지
- 본문 끝 페이지는 종문 시작 페이지 - 1

---

## 5. 예외 처리

### 5.1 Footer가 없는 페이지

**5.1.1 Footer 미탐지**
- Footer 영역이 없는 페이지는 이전 페이지의 영역을 따라감
- 예: 페이지 5에 Footer가 없으면, 페이지 3의 영역(본문/서문/종문)을 사용

**5.1.2 Footer 텍스트가 없는 경우**
- Footer 영역은 있지만 텍스트가 없는 경우
- 이전 페이지의 영역을 따라감

### 5.2 숫자가 없는 본문 페이지

**5.2.1 숫자 미추출**
- 본문 영역으로 판단된 페이지의 Footer에 숫자가 없는 경우
- 이전 페이지의 챕터 번호를 사용
- 예: 페이지 5가 본문이고 Footer에 숫자가 없으면, 페이지 3의 챕터 번호를 사용

### 5.3 챕터 번호 불연속

**5.3.1 번호 건너뛰기**
- 챕터 번호가 연속적이지 않은 경우 (예: 1, 2, 4)
- 경고 로그 출력
- 건너뛰어진 번호는 무시하고 다음 번호를 사용

**5.3.2 번호 역순**
- 챕터 번호가 역순인 경우 (예: 3, 2, 1)
- 경고 로그 출력
- 역순 번호는 무시하고 이전 번호를 유지

### 5.4 종문 오탐지 방지

**5.4.1 부분 문자열 매칭 주의사항**
- END_KEYWORDS의 키워드가 부분 문자열로 매칭될 수 있음
- 예: "주" 키워드가 "자주" 안에 포함되어 오탐지 가능
- 해결: 전체 Footer 텍스트 확인 및 매칭된 키워드 로깅으로 디버깅 지원

**5.4.2 Footer 요소 추출 조건 강화**
- `y0 > 0.9` 조건으로 Footer 영역을 더 엄격하게 제한 (기존 0.8에서 강화)
- 페이지 하단 10% 영역만 Footer로 인식하여 오탐지 감소

---

## 6. 성능 고려사항

### 6.1 홀수 페이지만 처리

**6.1.1 효율성**
- Footer 구조 판별자는 홀수 페이지(좌측)에만 나타나므로, 홀수 페이지만 처리
- 짝수 페이지는 인접한 홀수 페이지의 결과를 재사용
- 처리할 페이지 수가 절반으로 줄어듦

### 6.2 Footer 영역만 처리

**6.2.1 효율성**
- 전체 페이지 텍스트가 아닌 Footer 영역만 처리
- 처리할 텍스트 양이 크게 줄어듦

---

## 요약

1. **Footer 기반 본문 탐지**: Footer 구조 판별자의 숫자 포함 여부와 서문/종문 키워드를 기준으로 서문/본문/종문 구분
2. **Footer 기반 챕터 탐지**: Footer 구조 판별자에 나타나는 숫자를 기준으로 챕터 구분 (특별한 식별자 무시)
3. **좌측 페이지 우선**: 홀수 페이지(좌측)의 Footer를 기준으로 판단하고, 짝수 페이지(우측)는 인접한 홀수 페이지와 동일하게 처리
4. **LLM 보정 제외**: 휴리스틱 기반 구조 분석만 사용 (LLM 보정 로직 미적용)

