# 구조 분석 로직 가이드라인

이 문서는 Footer 기반 구조 분석 모듈의 설계 원칙, 구현 가이드라인, 그리고 실제 프로젝트에서 얻은 레슨을 정리합니다.

## 목차

1. [핵심 원칙](#1-핵심-원칙)
2. [페이지 번호 일관성](#2-페이지-번호-일관성)
3. [Footer 요소 추출](#3-footer-요소-추출)
4. [Footer 요소 분류](#4-footer-요소-분류)
5. [본문/종문 경계 탐지](#5-본문종문-경계-탐지)
6. [챕터 번호 추출](#6-챕터-번호-추출)
7. [챕터 경계 계산](#7-챕터-경계-계산)
8. [레슨 및 주의사항](#8-레슨-및-주의사항)
9. [현재 지원하는 챕터 패턴](#9-현재-지원하는-챕터-패턴)
10. [알려진 제한사항](#10-알려진-제한사항)

---

## 1. 핵심 원칙

### 1.1 기본 원칙

- **홀수 페이지 우선**: 모든 판단은 홀수 페이지(좌측)의 Footer를 기준으로 수행
- **Footer 기반**: 페이지 하단(y0 > 0.9) 또는 category='footer'인 요소만 사용
- **챕터 표시 판별자 우선**: Footer 요소 중 챕터 표시 판별자(`chapter_marker`)를 최우선으로 사용
- **페이지 번호 제외**: Footer의 페이지 번호는 챕터 탐지에서 제외

### 1.2 페이지 번호 일관성 (최우선 원칙)

**⚠️ 가장 중요한 원칙**: 페이지 번호 일관성은 챕터 탐지의 핵심입니다.

- **좌측 페이지는 항상 홀수**: 원본 PDF 페이지를 좌/우로 분할할 때, 좌측은 항상 홀수 번호를 할당
- **우측 페이지는 항상 짝수**: 원본 PDF 페이지를 좌/우로 분할할 때, 우측은 항상 짝수 번호를 할당
- **컨텐츠 유무와 무관**: 좌측에 컨텐츠가 없어도 홀수 번호를 할당 (빈 페이지 생성)
- **일관성 보장**: 이 규칙을 위반하면 챕터 탐지가 실패할 수 있음

**구현 위치**: `backend/parsers/pdf_parser.py`의 `_split_pages_by_side()` 메서드

---

## 2. 페이지 번호 일관성

### 2.1 왜 중요한가?

챕터 탐지 로직은 **홀수 페이지만** 검사합니다. 따라서:
- 좌측 페이지가 홀수가 아니면 → 챕터 마커를 놓침
- 우측 페이지가 짝수가 아니면 → 페이지 번호 판별 오류 가능

### 2.2 구현 규칙

```python
# backend/parsers/pdf_parser.py
def _split_pages_by_side(self, elements: List[Dict], force_split: bool) -> List[Dict]:
    """
    원본 PDF 페이지를 좌/우로 분할하고, 일관된 페이지 번호 할당
    
    규칙:
    - 좌측 페이지: 항상 홀수 (1, 3, 5, 7, ...)
    - 우측 페이지: 항상 짝수 (2, 4, 6, 8, ...)
    - 컨텐츠가 없어도 페이지 생성 (일관성 보장)
    """
    result_pages = []
    page_counter = 1  # 전역 카운터
    
    for original_page in sorted(pages_dict.keys()):
        # 좌측 처리 (항상 홀수)
        result_pages.append({
            "page_number": page_counter,  # 홀수
            "side": "left",
            ...
        })
        page_counter += 1
        
        # 우측 처리 (항상 짝수)
        result_pages.append({
            "page_number": page_counter,  # 짝수
            "side": "right",
            ...
        })
        page_counter += 1
```

### 2.3 레슨

**문제**: 초기 구현에서 좌측에 컨텐츠가 없으면 페이지를 생성하지 않았음
- 결과: 좌측이 짝수 번호를 받는 경우 발생
- 영향: 홀수 페이지만 검사하는 챕터 탐지 로직이 챕터 마커를 놓침

**해결**: 좌측에 컨텐츠가 없어도 빈 페이지를 생성하여 홀수 번호 할당

---

## 3. Footer 요소 추출

### 3.1 추출 조건

**메서드**: `_get_footer_elements(page: Dict) -> List[Dict]`

**조건 (OR 관계)**:
1. `category == 'footer'`인 요소 (최우선)
2. `y0 > 0.9`인 요소 (페이지 하단 10% 영역)

**정렬**:
- `y0` 기준 내림차순 정렬 (하단에 가까울수록 우선)

### 3.2 구현 코드

```python
def _get_footer_elements(self, page: Dict) -> List[Dict]:
    elements = page.get("elements", [])
    footer_elements = []
    
    for elem in elements:
        # 1. category='footer'인 요소 (최우선)
        if elem.get("category") == "footer":
            footer_elements.append(elem)
            continue
        
        # 2. y0 좌표가 큰 요소 (페이지 하단)
        bbox = elem.get("bbox", {})
        y0 = bbox.get("y0", 0.0)
        if y0 > 0.9:  # 페이지 하단 10% 영역
            footer_elements.append(elem)
    
    # y0 기준으로 정렬 (하단에 가까울수록 우선)
    footer_elements.sort(
        key=lambda e: e.get("bbox", {}).get("y0", 0.0), reverse=True
    )
    
    return footer_elements
```

### 3.3 식별자

- **y0 좌표**: 정규화된 좌표 (0.0 ~ 1.0), 0.9 이상이면 Footer 영역
- **category**: Upstage API에서 제공하는 요소 분류 ('footer', 'text', 'title' 등)

---

## 4. Footer 요소 분류

### 4.1 분류 목적

Footer 요소를 3가지로 분류하여 챕터 표시 판별자만 추출:
- `chapter_marker`: 챕터 표시 판별자 (예: "제1장", "Chapter 1")
- `page_number`: 페이지 번호 (예: "36", "37")
- `other`: 기타 (저자명, 출판사 등)

### 4.2 분류 로직

**메서드**: `_classify_footer_element(elem: Dict) -> str`

**우선순위**:
1. **챕터 패턴 확인** (최우선)
   - 정규식 패턴 매칭으로 챕터 표시 판별자 확인
   - 매칭되면 → `chapter_marker`
2. **위치 기반 판단**
   - `x0 < 0.05` (왼쪽 끝) + 페이지 번호 패턴 → `page_number`
3. **중앙 영역 판단**
   - `0.05 < x0 < 0.5` (중앙) + 챕터 키워드 포함 → `chapter_marker`
4. **기타**
   - 위 조건에 해당하지 않으면 → `other`

### 4.3 챕터 패턴 목록

현재 지원하는 챕터 패턴은 [9. 현재 지원하는 챕터 패턴](#9-현재-지원하는-챕터-패턴) 섹션을 참고하세요.

### 4.4 페이지 번호 판별

**조건**:
- `x0 < 0.05` (왼쪽 끝 영역)
- 정규식: `^\d{1,3}$` (1-3자리 숫자만)
- 범위: 1-1000

### 4.5 챕터 키워드

**키워드 목록**: `["제", "장", "강", "부", "chapter", "part"]`

**사용 조건**:
- `0.05 < x0 < 0.5` (중앙 영역)
- 위 키워드 중 하나라도 포함되면 → `chapter_marker`

### 4.6 식별자

- **x0 좌표**: 정규화된 좌표 (0.0 ~ 1.0)
  - `x0 < 0.05`: 왼쪽 끝 (페이지 번호 영역)
  - `0.05 < x0 < 0.5`: 중앙 (챕터 제목 영역)
  - `x0 > 0.5`: 오른쪽 (기타)
- **정규식 패턴**: 챕터 표시 판별자 인식
- **키워드**: 챕터 관련 키워드로 보조 판별

---

## 5. 본문/종문 경계 탐지

### 5.1 본문 시작 페이지 탐지

**메서드**: `_detect_main_start_improved(pages: List[Dict]) -> int`

**단계**:
1. **홀수 페이지만 순회** (3페이지부터 시작, 1-2페이지는 표지로 제외)
2. **각 페이지의 Footer 요소 분류**
   - `_get_footer_elements()`로 Footer 요소 추출
   - `_classify_footer_element()`로 각 요소 분류
   - `chapter_marker` 분류된 요소만 추출
3. **챕터 표시 판별자 확인**
   - `chapter_marker`가 있으면 본문 시작 후보
4. **서문 키워드 확인**
   - 페이지 전체 텍스트에서 START_KEYWORDS 확인
   - 서문 키워드가 없으면 → 본문 시작으로 확정
5. **기본값**
   - 챕터 표시 판별자가 없으면 → 3페이지 (기본값)

**서문 키워드 목록**: `backend/config/constants.py`의 `START_KEYWORDS` 참고

### 5.2 종문 시작 페이지 탐지

**메서드**: `_detect_notes_start_improved(pages: List[Dict], main_start: int) -> Optional[int]`

**단계**:
1. **본문 후반부만 검사** (전체의 50% 이후 또는 본문 시작 이후)
2. **홀수 페이지만 역순 순회** (뒤에서 앞으로)
3. **각 페이지의 Footer 텍스트 추출**
   - Footer 요소들의 텍스트를 공백으로 연결
4. **종문 키워드 확인**
   - Footer 텍스트에서 END_KEYWORDS 부분 문자열 매칭
   - 매칭되면 → 종문 시작으로 확정

**⚠️ 중요 레슨: 단일 문자 키워드 처리**

단일 문자 키워드(예: "주")는 **단독 단어로만** 매칭해야 합니다.

**문제 예시**:
- Footer 텍스트: "민주사회주의"
- 기존 로직: "주"가 포함되어 있으므로 종문으로 오탐지
- 올바른 처리: "주"가 단독 단어로만 나타날 때만 매칭

**구현**:
```python
def _detect_notes_start_improved(self, pages: List[Dict], main_start: int) -> Optional[int]:
    for page in pages:
        footer_text = self._get_footer_text(page)
        
        matched_keywords = []
        for keyword in END_KEYWORDS:
            keyword_lower = keyword.lower()
            footer_lower = footer_text.lower()
            
            # 단일 문자 키워드는 단독으로만 매칭
            if len(keyword) == 1:
                # 공백으로 분리된 단어들 중에 정확히 키워드가 있는지 확인
                words = footer_lower.split()
                if keyword_lower in words:
                    matched_keywords.append(keyword)
            else:
                # 다중 문자 키워드는 기존 방식 (부분 문자열 매칭)
                if keyword_lower in footer_lower:
                    matched_keywords.append(keyword)
        
        if matched_keywords:
            return page_num
```

**종문 키워드 목록**: `backend/config/constants.py`의 `END_KEYWORDS` 참고

---

## 6. 챕터 번호 추출

### 6.1 추출 목적

본문 영역의 각 홀수 페이지에서 챕터 번호를 추출합니다.

### 6.2 추출 로직

**메서드**: `_extract_chapter_numbers_improved(pages: List[Dict]) -> Dict[int, Optional[int]]`

**단계**:
1. **본문 영역의 홀수 페이지만 필터링**
2. **각 페이지의 Footer 요소 분류**
   - `_get_footer_elements()`로 Footer 요소 추출
   - `_classify_footer_element()`로 각 요소 분류
   - `chapter_marker` 분류된 요소만 추출
3. **챕터 패턴에서 숫자 추출**
   - `_extract_chapter_number_from_pattern()`로 패턴에서 숫자 추출
   - 첫 번째 매칭된 패턴의 숫자를 챕터 번호로 사용
4. **결과 저장**
   - `{page_number: chapter_number or None}` 형식으로 저장

### 6.3 챕터 번호 추출 로직

**메서드**: `_extract_chapter_number_from_pattern(text: str) -> Optional[int]`

**단계**:
1. **챕터 패턴 순회**
   - 각 정규식 패턴에 대해 `search()` 실행 (문자열 전체 검색)
2. **매칭 그룹에서 숫자 추출**
   - 패턴의 첫 번째 그룹 `(\d+)`에서 숫자 추출
   - 예: "제1장" → 패턴 `제\s*(\d+)\s*[장강부]` → 그룹 1 → `1`
3. **유효성 검증**
   - 숫자가 1 이상이면 유효
4. **반환**
   - 유효한 숫자 반환, 없으면 `None`

**⚠️ 중요**: `search()` 메서드 사용 (문자열 전체 검색)
- `match()`는 문자열 시작만 검사하므로 사용하지 않음
- `search()`는 문자열 어디서든 패턴을 찾을 수 있음

### 6.4 챕터 번호 연속성 필터링

**메서드**: `_filter_valid_chapter_numbers(page_chapter_numbers: Dict[int, Optional[int]]) -> Dict[int, Optional[int]]`

**목적**: 비연속적인 챕터 번호 제거 (예: [1, 2, 3, 100, 200] → [1, 2, 3])

**단계**:
1. **모든 챕터 번호 수집**
2. **가장 긴 연속 시퀀스 찾기**
   - `_find_continuous_sequence()`로 연속적인 번호 시퀀스 찾기
   - 예: [1, 2, 3, 4, 5, 6, 7, 100, 200] → {1, 2, 3, 4, 5, 6, 7}
3. **유효한 번호만 유지**
   - 연속 시퀀스에 포함된 번호만 유지
   - 나머지는 `None`으로 변경

**레슨**: 연속성 필터링은 오탐지를 줄이는 데 중요하지만, 일부 챕터가 누락될 수 있음
- 예: 챕터 1, 2, 3, 4, 5, 6, 7 중 챕터 7만 누락되면 → [1, 2, 3, 4, 5, 6]만 유지
- 해결: 챕터 번호 추출 로직을 개선하여 누락을 최소화

---

## 7. 챕터 경계 계산

### 7.1 계산 목적

챕터 번호가 변경되는 지점을 찾아 각 챕터의 시작/끝 페이지를 계산합니다.

### 7.2 경계 계산 로직

**메서드**: `_detect_chapter_boundaries(page_chapter_numbers: Dict[int, Optional[int]], main_pages: List[int]) -> List[Dict[str, Any]]`

**단계**:
1. **페이지 번호 순서대로 정렬**
2. **챕터 번호 변경 지점 탐지**
   - 현재 챕터 번호와 다른 번호가 나타나면 → 새 챕터 시작
   - 이전 챕터의 끝 페이지 = 새 챕터 시작 페이지 - 1
3. **마지막 챕터 처리**
   - 마지막 챕터의 끝 페이지 = 본문 끝 페이지
4. **짝수 페이지 포함 조정**
   - `_adjust_boundaries_for_even_pages()`로 짝수 페이지도 포함

### 7.3 짝수 페이지 조정

**메서드**: `_adjust_boundaries_for_even_pages(chapters: List[Dict], main_pages: List[int]) -> List[Dict]`

**로직**:
- 다음 챕터가 홀수 페이지에서 시작하면 → 현재 챕터는 그 전 짝수 페이지까지
- 다음 챕터가 짝수 페이지에서 시작하면 → 현재 챕터는 그 전 홀수 페이지까지
- 마지막 챕터는 본문 끝 페이지까지

---

## 8. 레슨 및 주의사항

### 8.1 페이지 번호 일관성 (최우선)

**레슨**: 페이지 번호 일관성은 챕터 탐지의 핵심입니다.

- 좌측 페이지는 항상 홀수, 우측 페이지는 항상 짝수
- 컨텐츠 유무와 무관하게 일관된 번호 할당
- 이 규칙을 위반하면 챕터 탐지가 실패할 수 있음

**영향**: 페이지 번호 일관성 문제로 인해 2개 도서가 실패했으나, 수정 후 통과

### 8.2 단일 문자 키워드 처리

**레슨**: 단일 문자 키워드(예: "주")는 단독 단어로만 매칭해야 합니다.

- 부분 문자열 매칭 시 오탐지 발생 (예: "민주사회주의" 안의 "주")
- 해결: 공백으로 분리된 단어들 중에 정확히 키워드가 있는지 확인

**영향**: "99를위한경제"의 본문 끝 탐지 오류를 해결

### 8.3 챕터 패턴 확장

**레슨**: 다양한 챕터 표기 형식에 대응하기 위해 패턴을 확장해야 합니다.

**추가된 패턴**:
- `^\d+[_\-\s]+[가-힣]`: "1_제목", "1-제목", "1 제목" 형식
- `^0?\d+[_\-\s]+[가-힣]`: "01 바빌론", "1_제목" 형식 (앞에 0 가능)
- `^\d+_\s*[가-힣A-Z0-9]`: "1_3D", "1_제목" 형식 (영문/숫자 허용)

**주의사항**: 패턴이 너무 일반적이면 오탐지 발생 가능
- 예: `^0?\d+[_\-\s]+[가-힣]` 패턴이 "01 바빌론" 같은 도시명까지 챕터로 인식
- 해결: 특정 도서에 대해서는 챕터 개수 검증을 스킵하거나, 패턴을 더 구체적으로 제한

### 8.4 챕터 번호 추출 로직

**레슨**: `search()` 메서드를 사용하여 문자열 전체에서 패턴을 검색해야 합니다.

- `match()`는 문자열 시작만 검사하므로 사용하지 않음
- `search()`는 문자열 어디서든 패턴을 찾을 수 있음

**주의사항**: 특수 접두사(예: `[c]`)가 있는 경우 패턴 매칭 실패 가능
- 예: `[c]4_실전! 제작에서 창업까지의 모든 것` 형식
- 해결: 접두사를 제거하거나, 다른 방법으로 처리 (현재 미해결)

### 8.5 연속성 필터링

**레슨**: 연속성 필터링은 오탐지를 줄이는 데 중요하지만, 일부 챕터가 누락될 수 있습니다.

- 비연속적인 챕터 번호는 제거됨
- 챕터 번호 추출 로직을 개선하여 누락을 최소화해야 함

---

## 9. 현재 지원하는 챕터 패턴

### 9.1 패턴 목록

다음 정규식 패턴들이 `backend/structure/content_boundary_detector.py`와 `backend/structure/chapter_detector.py`에 정의되어 있습니다:

1. `제\s*(\d+)\s*[장강부]` → "제1장", "제 1 장", "제1강", "제1부"
2. `CHAPTER\s*(\d+)` (대소문자 무시) → "Chapter 1", "Chapter1", "CHAPTER 1"
3. `Part\s*(\d+)` (대소문자 무시) → "Part 1", "Part1"
4. `^(\d+)\s*[장강부]` → "1장", "1 장", "1강"
5. `^(\d+)\.\s*[가-힣]` → "1. 제목", "1.제목"
6. `^(\d+)[_\-\s]+[가-힣]` → "1_제목", "1-제목", "1 제목" (한글 필수)
7. `^(0?\d+)[_\-\s]+[가-힣]` → "01 바빌론", "1_제목" (앞에 0 가능)
8. `^(\d+)_\s*[가-힣A-Z0-9]` → "1_3D", "1_제목" (3D프린터의모든것 - 영문/숫자 허용)

**참고**: `chapter_detector.py`의 패턴은 숫자를 추출하기 위해 캡처 그룹 `(\d+)`를 포함합니다.

### 9.2 패턴 확장 이력

- **초기 패턴**: 1-5번 패턴만 지원
- **1차 확장**: 6-7번 패턴 추가 (30개도시로읽는세계사, 기타 도서 대응)
- **2차 확장**: 8번 패턴 추가 (3D프린터의모든것 본문 시작 페이지 대응)

### 9.3 패턴 확장 시 주의사항

- **오탐지 가능성**: 패턴이 너무 일반적이면 오탐지 발생 가능
  - 예: `^0?\d+[_\-\s]+[가-힣]` 패턴이 "01 바빌론" 같은 도시명까지 챕터로 인식
- **특정 도서 처리**: 특정 도서에 대해서는 챕터 개수 검증을 스킵할 수 있음
  - 예: "30개도시로읽는세계사"는 챕터 개수 검증 스킵
- **접두사 처리**: 특수 접두사(예: `[c]`)가 있는 경우 패턴 매칭 실패 가능
  - 현재 미해결: "3D프린터의모든것" 챕터 4번 (`[c]4_실전!` 형식)

---

## 10. 알려진 제한사항

### 10.1 특수 접두사 미지원

**문제**: 특수 접두사(예: `[c]`)가 있는 챕터 마커는 현재 패턴으로 인식 불가

**예시**:
- Footer 텍스트: `[c]4_실전! 제작에서 창업까지의 모든 것`
- 현재 패턴: `^(\d+)_\s*[가-힣A-Z0-9]`는 `[c]` 접두사 때문에 매칭 실패

**영향 도서**: "3D프린터의모든것" 챕터 4번 (241페이지)

**해결 방안** (미구현):
- 접두사를 제거하는 전처리 로직 추가
- 또는 접두사를 허용하는 패턴 추가 (단, 오탐지 가능성 고려)

### 10.2 특정 형식 미지원

**문제**: "법칙 N" 형식의 챕터 마커는 현재 패턴으로 인식 불가

**예시**:
- Footer 텍스트: `법칙 1 어깨를 펴고 똑바로 서라`
- 현재 패턴: "법칙" 키워드가 포함된 패턴 없음

**영향 도서**: "12가지인생의법칙" (개선 방안 재검토 중)

**해결 방안** (미구현):
- `법칙\s*\d+` 패턴 추가 (단, 너무 일반적이어서 오탐지 가능성 고려)

### 10.3 연속성 필터링으로 인한 누락

**문제**: 연속성 필터링이 일부 챕터를 누락시킬 수 있음

**예시**:
- 챕터 번호: [1, 2, 3, 4, 5, 6, 7]
- 챕터 7번만 추출 실패 → [1, 2, 3, 4, 5, 6]만 유지
- 결과: 챕터 7번이 누락됨

**영향 도서**: "99를위한경제" 챕터 7번 (321페이지)

**해결 방안** (미구현):
- 챕터 번호 추출 로직 개선
- 연속성 필터링 기준 재검토

---

## 참고 문서

- **상세 구현 설명**: `docs/structure_analysis_logic_detailed.md`
- **E2E 테스트 결과**: `data/output/e2e_test_results_summary.md`
- **실패 도서 분석**: `data/output/failed_books_analysis_report.md`
- **구조 분석 로직 설명**: `docs/structure_analysis_logic_explanation_v2.md`

---

## 변경 이력

- **2025-11-27**: 초기 문서 작성
  - 페이지 번호 일관성 원칙 추가
  - 단일 문자 키워드 처리 레슨 추가
  - 챕터 패턴 확장 이력 추가
  - 알려진 제한사항 추가

